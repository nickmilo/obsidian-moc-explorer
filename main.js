/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  VIEW_TYPE_MOC_EXPLORER: () => VIEW_TYPE_MOC_EXPLORER,
  default: () => MOCExplorerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// Default settings
const DEFAULT_SETTINGS = {
  mocFolderPath: "Atlas/Maps",
  showConnectionStrength: true,
  maxNodeSize: 50,
  colorScheme: "purple",
  autoRefresh: true,
  minimumConnections: 1
};

const VIEW_TYPE_MOC_EXPLORER = "moc-explorer-view";

// MOC Explorer View
class MOCExplorerView extends import_obsidian.ItemView {
  constructor(leaf, settings) {
    super(leaf);
    this.mocData = { nodes: [], links: [] };
    this.svg = null;
    this.settings = settings;
  }
  getViewType() {
    return VIEW_TYPE_MOC_EXPLORER;
  }
  getDisplayText() {
    return "MOC Explorer";
  }
  getIcon() {
    return "network";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    const mainContainer = container.createDiv({ cls: "moc-explorer-container" });
    const toolbar = mainContainer.createDiv({ cls: "moc-explorer-toolbar" });
    const refreshBtn = toolbar.createEl("button", {
      text: "\u{1F504} Refresh",
      cls: "mod-cta"
    });
    refreshBtn.addEventListener("click", () => this.refreshData());
    const filterSelect = toolbar.createEl("select", { cls: "dropdown" });
    filterSelect.createEl("option", { text: "All MOCs", value: "all" });
    filterSelect.createEl("option", { text: "Main MOCs", value: "main" });
    filterSelect.createEl("option", { text: "Sub MOCs", value: "sub" });
    filterSelect.createEl("option", { text: "System MOCs", value: "system" });
    filterSelect.addEventListener("change", (e) => {
      const target = e.target;
      this.filterNodes(target.value);
    });
    const searchInput = toolbar.createEl("input", {
      type: "text",
      placeholder: "Search MOCs...",
      cls: "search-input"
    });
    searchInput.addEventListener("input", (e) => {
      const target = e.target;
      this.searchNodes(target.value);
    });
    const vizContainer = mainContainer.createDiv({ cls: "moc-viz-container" });
    this.svg = vizContainer.createSvg("svg", {
      attr: {
        width: "100%",
        height: "600px"
      }
    });
    const statsPanel = mainContainer.createDiv({ cls: "moc-stats-panel" });
    this.createStatsPanel(statsPanel);
    await this.refreshData();
    if (this.settings.autoRefresh) {
      this.setupAutoRefresh();
    }
  }
  createStatsPanel(container) {
    container.createEl("h3", { text: "MOC Statistics" });
    const statsGrid = container.createDiv({ cls: "stats-grid" });
    const totalStat = statsGrid.createDiv({ cls: "stat-item" });
    totalStat.createEl("div", { text: "0", cls: "stat-value", attr: { id: "total-mocs" } });
    totalStat.createEl("div", { text: "Total MOCs", cls: "stat-label" });
    const connectionsStat = statsGrid.createDiv({ cls: "stat-item" });
    connectionsStat.createEl("div", { text: "0", cls: "stat-value", attr: { id: "total-connections" } });
    connectionsStat.createEl("div", { text: "Connections", cls: "stat-label" });
    const orphansStat = statsGrid.createDiv({ cls: "stat-item" });
    orphansStat.createEl("div", { text: "0", cls: "stat-value", attr: { id: "orphan-mocs" } });
    orphansStat.createEl("div", { text: "Orphaned", cls: "stat-label" });
    const avgStat = statsGrid.createDiv({ cls: "stat-item" });
    avgStat.createEl("div", { text: "0", cls: "stat-value", attr: { id: "avg-connections" } });
    avgStat.createEl("div", { text: "Avg Links", cls: "stat-label" });
  }
  async refreshData() {
    try {
      new import_obsidian.Notice("Scanning MOCs...");
      this.mocData = await this.scanMOCs();
      this.renderVisualization();
      this.updateStats();
      new import_obsidian.Notice(`Found ${this.mocData.nodes.length} MOCs`);
    } catch (error) {
      new import_obsidian.Notice("Error scanning MOCs: " + error.message);
      console.error("MOC Explorer error:", error);
    }
  }
  async scanMOCs() {
    const nodes = [];
    const links = [];
    const mocFolder = this.app.vault.getAbstractFileByPath(this.settings.mocFolderPath);
    if (!mocFolder || !(mocFolder instanceof import_obsidian.TFile)) {
      return this.scanEntireVault();
    }
    const mocFiles = this.app.vault.getMarkdownFiles().filter((file) => file.path.startsWith(this.settings.mocFolderPath));
    for (const file of mocFiles) {
      const mocNode = await this.processMOCFile(file);
      if (mocNode) {
        nodes.push(mocNode);
      }
    }
    for (const node of nodes) {
      for (const outlink of node.outlinks) {
        const targetNode = nodes.find((n) => n.path === outlink || n.name === outlink);
        if (targetNode) {
          links.push({
            source: node.id,
            target: targetNode.id,
            strength: this.calculateLinkStrength(node, targetNode)
          });
        }
      }
    }
    return { nodes, links };
  }
  async scanEntireVault() {
    const nodes = [];
    const links = [];
    const allFiles = this.app.vault.getMarkdownFiles();
    const mocFiles = allFiles.filter((file) => file.basename.toLowerCase().includes("moc") || file.basename.toLowerCase().includes("map") || file.path.includes("Maps") || file.path.includes("Atlas"));
    for (const file of mocFiles) {
      const mocNode = await this.processMOCFile(file);
      if (mocNode) {
        nodes.push(mocNode);
      }
    }
    for (const node of nodes) {
      for (const outlink of node.outlinks) {
        const targetNode = nodes.find((n) => n.name === outlink);
        if (targetNode) {
          links.push({
            source: node.id,
            target: targetNode.id,
            strength: this.calculateLinkStrength(node, targetNode)
          });
        }
      }
    }
    return { nodes, links };
  }
  async processMOCFile(file) {
    var _a, _b;
    try {
      const content = await this.app.vault.read(file);
      const cache = this.app.metadataCache.getFileCache(file);
      const inlinks = Object.keys(this.app.metadataCache.resolvedLinks).filter((linkPath) => {
        const links2 = this.app.metadataCache.resolvedLinks[linkPath];
        return links2 && links2[file.path];
      });
      const outlinks = ((_b = (_a = cache == null ? void 0 : cache.links) == null ? void 0 : _a.map((link) => link.link)) != null ? _b : []);
      const type = this.determineMOCType(file, content);
      const category = this.determineMOCCategory(file, content);
      return {
        id: file.path,
        name: file.basename,
        path: file.path,
        connections: inlinks.length + outlinks.length,
        inlinks,
        outlinks,
        type,
        category
      };
    } catch (error) {
      console.error(`Error processing MOC file ${file.path}:`, error);
      return null;
    }
  }
  determineMOCType(file, content) {
    const filename = file.basename.toLowerCase();
    const path = file.path.toLowerCase();
    if (filename.includes("home") || filename.includes("atlas") || filename.includes("index") || path.includes("system")) {
      return "system";
    }
    if (path.split("/").length <= 2 && !filename.includes("sub")) {
      return "main";
    }
    return "sub";
  }
  determineMOCCategory(file, content) {
    const filename = file.basename.toLowerCase();
    if (filename.includes("writing") || filename.includes("creative"))
      return "creative";
    if (filename.includes("pkm") || filename.includes("knowledge"))
      return "knowledge";
    if (filename.includes("people") || filename.includes("personal"))
      return "personal";
    if (filename.includes("system") || filename.includes("home"))
      return "system";
    return "general";
  }
  calculateLinkStrength(nodeA, nodeB) {
    const commonConnections = nodeA.outlinks.filter((link) => nodeB.outlinks.includes(link) || nodeB.inlinks.includes(link)).length;
    return Math.min(commonConnections + 1, 5);
  }
  renderVisualization() {
    if (!this.svg)
      return;
    this.svg.empty();
    const width = this.svg.clientWidth || 800;
    const height = 600;
    const g = this.svg.createSvg("g");
    const linksGroup = g.createSvg("g", { cls: "links" });
    const nodesGroup = g.createSvg("g", { cls: "nodes" });
    const nodes = [...this.mocData.nodes];
    const links = [...this.mocData.links];
    const radius = Math.min(width, height) / 3;
    const centerX = width / 2;
    const centerY = height / 2;
    nodes.forEach((node, i) => {
      const angle = i / nodes.length * 2 * Math.PI;
      node.x = centerX + Math.cos(angle) * radius;
      node.y = centerY + Math.sin(angle) * radius;
    });
    links.forEach((link) => {
      const sourceNode = nodes.find((n) => n.id === link.source);
      const targetNode = nodes.find((n) => n.id === link.target);
      if (sourceNode && targetNode) {
        const line = linksGroup.createSvg("line", {
          attr: {
            x1: sourceNode.x,
            y1: sourceNode.y,
            x2: targetNode.x,
            y2: targetNode.y,
            stroke: "#7c3aed",
            "stroke-width": link.strength,
            opacity: 0.6
          }
        });
      }
    });
    nodes.forEach((node) => {
      const nodeGroup = nodesGroup.createSvg("g", {
        attr: {
          transform: `translate(${node.x}, ${node.y})`
        }
      });
      const circle = nodeGroup.createSvg("circle", {
        attr: {
          r: Math.min(10 + node.connections * 2, this.settings.maxNodeSize),
          fill: this.getNodeColor(node),
          stroke: "#fff",
          "stroke-width": 2
        },
        cls: "moc-node"
      });
      nodeGroup.createSvg("text", {
        attr: {
          "text-anchor": "middle",
          dy: "0.35em",
          fill: "#fff",
          "font-size": "10px",
          "font-weight": "600"
        },
        text: node.name.length > 15 ? node.name.substring(0, 15) + "..." : node.name
      });
      nodeGroup.addEventListener("click", () => {
        this.openMOC(node.path);
      });
      this.addTooltip(nodeGroup, node);
    });
  }
  getNodeColor(node) {
    const colorSchemes = {
      purple: {
        main: "#7c3aed",
        sub: "#a78bfa",
        system: "#60a5fa"
      },
      blue: {
        main: "#2563eb",
        sub: "#60a5fa",
        system: "#34d399"
      }
    };
    const scheme = colorSchemes[this.settings.colorScheme] || colorSchemes.purple;
    return scheme[node.type];
  }
  addTooltip(element, node) {
    element.addEventListener("mouseenter", (e) => {
      const tooltip = document.createElement("div");
      tooltip.className = "moc-tooltip";
      tooltip.innerHTML = `
				<div class="tooltip-title">${node.name}</div>
				<div class="tooltip-content">
					<div>Type: ${node.type}</div>
					<div>Category: ${node.category}</div>
					<div>Connections: ${node.connections}</div>
					<div>Path: ${node.path}</div>
				</div>
			`;
      document.body.appendChild(tooltip);
      const rect = element.getBoundingClientRect();
      tooltip.style.left = rect.left + "px";
      tooltip.style.top = rect.top - tooltip.offsetHeight - 10 + "px";
    });
    element.addEventListener("mouseleave", () => {
      const tooltip = document.querySelector(".moc-tooltip");
      if (tooltip) {
        tooltip.remove();
      }
    });
  }
  async openMOC(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (file instanceof import_obsidian.TFile) {
      await this.app.workspace.getLeaf().openFile(file);
    }
  }
  updateStats() {
    const totalElement = document.getElementById("total-mocs");
    const connectionsElement = document.getElementById("total-connections");
    const orphansElement = document.getElementById("orphan-mocs");
    const avgElement = document.getElementById("avg-connections");
    if (totalElement)
      totalElement.textContent = this.mocData.nodes.length.toString();
    const totalConnections = this.mocData.links.length;
    if (connectionsElement)
      connectionsElement.textContent = totalConnections.toString();
    const orphanedMOCs = this.mocData.nodes.filter((n) => n.connections === 0).length;
    if (orphansElement)
      orphansElement.textContent = orphanedMOCs.toString();
    const avgConnections = this.mocData.nodes.length > 0 ? (this.mocData.nodes.reduce((sum, n) => sum + n.connections, 0) / this.mocData.nodes.length).toFixed(1) : "0";
    if (avgElement)
      avgElement.textContent = avgConnections;
  }
  filterNodes(filter) {
    new import_obsidian.Notice(`Filtering by: ${filter}`);
  }
  searchNodes(query) {
    new import_obsidian.Notice(`Searching for: ${query}`);
  }
  setupAutoRefresh() {
    this.app.vault.on("modify", (file) => {
      if (file.path.startsWith(this.settings.mocFolderPath)) {
        setTimeout(() => this.refreshData(), 1e3);
      }
    });
  }
  async onClose() {
  }
}

// Settings Tab
class MOCExplorerSettingTab extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "MOC Explorer Settings" });
    new import_obsidian.Setting(containerEl).setName("MOC Folder Path").setDesc("Path to folder containing your MOCs").addText((text) => text.setPlaceholder("Atlas/Maps").setValue(this.plugin.settings.mocFolderPath).onChange(async (value) => {
      this.plugin.settings.mocFolderPath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Show Connection Strength").setDesc("Display connection strength between MOCs").addToggle((toggle) => toggle.setValue(this.plugin.settings.showConnectionStrength).onChange(async (value) => {
      this.plugin.settings.showConnectionStrength = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Maximum Node Size").setDesc("Maximum size for MOC nodes in the visualization").addSlider((slider) => slider.setLimits(20, 100, 10).setValue(this.plugin.settings.maxNodeSize).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.maxNodeSize = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Color Scheme").setDesc("Color scheme for the visualization").addDropdown((dropdown) => dropdown.addOption("purple", "Purple").addOption("blue", "Blue").setValue(this.plugin.settings.colorScheme).onChange(async (value) => {
      this.plugin.settings.colorScheme = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Auto Refresh").setDesc("Automatically refresh when MOCs are modified").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoRefresh).onChange(async (value) => {
      this.plugin.settings.autoRefresh = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Minimum Connections").setDesc("Minimum number of connections to display a MOC").addSlider((slider) => slider.setLimits(0, 10, 1).setValue(this.plugin.settings.minimumConnections).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.minimumConnections = value;
      await this.plugin.saveSettings();
    }));
  }
}

// Main Plugin Class
class MOCExplorerPlugin extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerView(
      VIEW_TYPE_MOC_EXPLORER,
      (leaf) => new MOCExplorerView(leaf, this.settings)
    );
    this.addRibbonIcon("network", "Open MOC Explorer", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-moc-explorer",
      name: "Open MOC Explorer",
      callback: () => {
        this.activateView();
      }
    });
    this.addSettingTab(new MOCExplorerSettingTab(this.app, this));
    console.log("MOC Explorer plugin loaded");
  }
  async onunload() {
    console.log("MOC Explorer plugin unloaded");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_MOC_EXPLORER);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      await (leaf == null ? void 0 : leaf.setViewState({ type: VIEW_TYPE_MOC_EXPLORER, active: true }));
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
}

module.exports = MOCExplorerPlugin;